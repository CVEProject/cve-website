import { defineStore } from 'pinia';
import axios from 'axios';

export const useCveListSearchStore = defineStore('cveListSearch ', {
  state: () => { 
    return {
      cveId: '',
      from: 0,
      isArecord: undefined,
      isSeachButtonDisabled: true, // findDisabled
      isIdOrRecordFound: true,
      isPublished: false,
      isReserved: false,
      isRejected: false,
      isSearching: false,
      isLookingUpRecord: false,
      isQueryingSearchService: false,
      isLookUpRecordServerError: false,
      isSearchServerError: false,
      query: '',
      recordData: {},
      searchResults: [],
      serverError: false,
      showHelpText: false,
      size: 25,
      totalExecutingRequests: -1,
      totalSearchResultCount: 0,
      pagination: {
        startWindow: 1,
        endWindow: undefined,
        firstPage: 1,
        currentPage: 1,
        currentPageWindow: [],
        totalPages: undefined,
        maxPageWindow: 5,
        numberPerPage: 25,
        sortBy: {
          field: 'cveId',
          direction: 'desc',
          label: 'CVE ID (newest to oldest)',
          selected: true
        },
        sortByOptions: [
          {
            field: 'cveId',
            direction: 'desc',
            label: 'CVE ID (newest to oldest)',
            selected: true
          },
          {
            field: 'cveId',
            direction: 'asc',
            label: 'CVE ID (oldest to newest)',
            selected: false
          },
          {
            field: 'relevancy',
            direction: 'desc',
            label: 'Relevancy (most to least)',
            selected: false
          },
          {
            field: 'relevancy',
            direction: 'asc',
            label: 'Relevancy (least to most)',
            selected: false
          }
        ],
        numberPerPageOptions: [25, 50, 100, 200],
        fromCount: undefined,
        toCount: undefined
      },
    }
  },
  actions: {
    decrement(field) {
      this[field] -= 1;
    },
    isCveIdPattern() {
      return new RegExp(/^CVE-\d{4}-\d{4,7}$/, 'i').test(this.query);
    },
    async search() {
      console.log(`>> search()`)
      this.isSearching = true;
      try{

        console.log('search() >> about to call getSearchResults()')
        // * 2nd, query search service
        this.totalExecutingRequests = 1;
        await this.getSearchResults();
        console.log('search() >> just called getSearchResults()')

        // * Check if keyword is CVE ID
        if (this.isCveIdPattern()) {
          this.totalExecutingRequests = 2;
          
          // 1st, lookup ID to get Record data, and continue to get CVE Records that mention that ID
          this.cveId = this.query.toUpperCase();
          console.log('search() >> about to call getRecordData()')
          await this.getRecordData();
          console.log('search() >> just called getRecordData()')
        }

      } catch (error) {
         throw new Error('search() >> error with getRecordData() and or getSearchResults()');
      } finally {
        this.isSearching = false;
        this.setUpInitialPagination();
      }
    },
    async getRecordData() {
      console.log(`>> getRecordData()`)
      this.isLookingUpRecord = true;
      const getRecordUrl = `/api/cve/${this.cveId}`;
      console.log('getRecordData >> getRecordUrl: ', getRecordUrl);

      try {
        axios.defaults.baseURL = `https://${import.meta.env.VITE_CVE_SERVICES_BASE_URL}`;
        const response = await axios.get(getRecordUrl);
        const cveRecordData = response?.data || {};
        console.log('getRecordData >> typeof response: ', typeof response);
        console.log('getRecordData >> cveRecordData', cveRecordData);
        this.isArecord = true;
        this.isIdOrRecordFound = false;

        // format description
        let descriptions = [];
        cveRecordData.containers?.cna?.descriptions.forEach((description) => {
          if (description.lang === "en") descriptions.push(description.value);
        });
        let recordDataSummary = {
          cveId: cveRecordData?.cveMetadata?.cveId || 'No ID provided',
          cna: cveRecordData?.cveMetadata?.assignerShortName || 'No CNA provided',
          descriptions: descriptions,
          relevancyScore: 'not appliciable'
        }
        this.recordData = recordDataSummary;
        console.log('getRecordData >>  this.recordData = recordDataSummary ', recordDataSummary)

        if (cveRecordData?.cveMetadata.state === 'PUBLISHED') {
          this.isPublished = true;
        } else if (cveRecordData?.cveMetadata.state === 'REJECTED') {
          this.isRejected = true;
        }

      } catch (e) {
        console.log(`getRecordData >> Catch error: ${e}`);
        this.isLookUpRecordServerError = true;

        this.isPublished = false;
        this.isReserved = false;
        this.isRejected = false;
        this.isIdOrRecordFound = false;
        this.isArecord = false;
        throw new Error('getRecordData >> throwing wrroe')
      } finally {
        this.isLookingUpRecord = false;
        this.decrement('totalExecutingRequests');
        console.log(`getRecordData >> finally`);
      }
    },
    async getSearchResults() {
      console.log(`>> getSearchResults()`)
      this.isQueryingSearchService = true;

      const instance = axios.create({
        baseURL: import.meta.env.VITE_API_BASE_URL,
      });

      try {
        let payLoad = this.createSearchPayload();
        // const response = await instance.post(
        //   import.meta.env.VITE_LIST_SEARCH_PATH,
        //   payLoad
        // );

        const response = {
          status: 200,
          data: {
            "resultsTotal": 9537,
            "data": [
                {
                    "_index": "cve-index-dev",
                    "_type": "_doc",
                    "_id": "CVE-2023-38421",
                    "_score": 6.435403,
                    "_source": {
                        "dataType": "CVE_RECORD",
                        "dataVersion": "5.0",
                        "cveMetadata": {
                            "cveId": "CVE-2023-38421",
                            "assignerOrgId": "286789f9-fbc2-4510-9f9a-43facdede74c",
                            "state": "PUBLISHED",
                            "assignerShortName": "apple",
                            "dateReserved": "2023-07-20T15:03:50.148Z",
                            "datePublished": "2023-07-27T00:30:33.653Z",
                            "dateUpdated": "2023-07-27T03:45:50.334Z"
                        },
                        "containers": {
                            "cna": {
                                "problemTypes": [
                                    {
                                        "descriptions": [
                                            {
                                                "lang": "en",
                                                "description": "Processing a 3D model may result in disclosure of process memory"
                                            }
                                        ]
                                    }
                                ],
                                "affected": [
                                    {
                                        "vendor": "Apple",
                                        "product": "macOS",
                                        "versions": [
                                            {
                                                "version": "unspecified",
                                                "status": "affected",
                                                "lessThan": "13.5",
                                                "versionType": "custom"
                                            }
                                        ]
                                    },
                                    {
                                        "vendor": "Apple",
                                        "product": "macOS",
                                        "versions": [
                                            {
                                                "version": "unspecified",
                                                "status": "affected",
                                                "lessThan": "12.6",
                                                "versionType": "custom"
                                            }
                                        ]
                                    }
                                ],
                                "descriptions": [
                                    {
                                        "lang": "en",
                                        "value": "The issue was addressed with improved checks. This issue is fixed in macOS Ventura 13.5, macOS Monterey 12.6.8. Processing a 3D model may result in disclosure of process memory."
                                    }
                                ],
                                "references": [
                                    {
                                        "url": "https://support.apple.com/en-us/HT213843"
                                    },
                                    {
                                        "url": "https://support.apple.com/en-us/HT213844"
                                    }
                                ],
                                "providerMetadata": {
                                    "orgId": "286789f9-fbc2-4510-9f9a-43facdede74c",
                                    "shortName": "apple",
                                    "dateUpdated": "2023-07-27T03:45:50.334Z"
                                }
                            }
                        }
                    },
                    "sort": [
                        "CVE-2023-38421"
                    ]
                }
            ]
        }
        }

        console.log('getSearchResults >> Search service response:', response);

        if (response.status === 200) {
          this.totalSearchResultCount = response.data.resultsTotal;
          console.log('getSearchResults >>> axios request competed successfully, totalSearchResultCount: ', this.totalSearchResultCount)
          this.processSearchResults(response.data.data);
        }

      } catch (e) {
        this.isSearchServerError = true;
        console.log('getSearchResults >> catch error : ', e);
        throw new Error(`getSearchResults >> : ${e}`)
      } finally {
        this.isQueryingSearchService = false;
        this.decrement('totalExecutingRequests');
        console.log(`getSearchResults >> finally`)
      }
    },
    processSearchResults(results){
      console.log(`>> processSearchResults()`)
      const parsedResults = [];

      if (results.length >> 0) {
        results.forEach((result) => {
          const descriptions = [];

          if (result?._source?.cveMetadata?.state === "PUBLISHED") {
            result?._source?.containers?.cna?.descriptions.forEach((description) => {
              if (description.lang === "en") descriptions.push(description.value);
            });
          } else if (result?._source?.cveMetadata?.state === "REJECTED") {
            result?._source?.containers?.cna?.rejectedReasons.forEach((rejectedReason) => {
              if (rejectedReason.lang === "en") descriptions.push(rejectedReason.value);
            });
          } else {
            descriptions.push('No description provided');
          }

          parsedResults.push({
            cveId: result._id,
            cna: result?._source?.cveMetadata?.assignerShortName || 'No CNA provided',
            descriptions: descriptions,
            relevancyScore: result?._score
          });
        });
      }

      this.searchResults = parsedResults;
    },
    setUpInitialPagination() {
      console.log('>> setUpInitialPagination ', this.pagination)
      if (Object.keys(this.pagination.currentPageWindow).length === 0 && !this.isLookUpRecordServerError && this.totalSearchResultCount > 0) {
        // sets up these values for the first search request and the rest is handled in SearchResults component
        this.pagination.totalPages = Math.ceil(this.totalSearchResultCount / this.pagination.numberPerPage);
        if (this.pagination.totalPages < this.pagination.maxPageWindow) {
          this.pagination.endWindow = this.pagination.maxPageWindow = this.pagination.totalPages;
        } else {
          this.pagination.endWindow = this.pagination.maxPageWindow;
        }

        this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
        this.calcToAndFromCounts();
        console.log('setUpInitialPagination >> after ', this.pagination)
      }
    },
    paginate() {
      console.log(`>> paginate()`)
      
      // search service starts at 0 while this app starts at 1
      this.from = (parseInt(this.pagination.currentPage) * parseInt(this.pagination.numberPerPage)) - parseInt(this.pagination.numberPerPage);
      if (parseInt(this.from) + parseInt(this.pagination.numberPerPage) > parseInt(this.totalSearchResultCount)) {
        this.size = parseInt(this.totalSearchResultCount) - parseInt(this.from);
      } else {
        this.size = parseInt(this.pagination.numberPerPage);
      }
      console.log(`paginate() >> ${this.from}, ${this.size}`);
      console.log(this.pagination);

      this.search();
    },
    calcRange(start, stop) {
      console.log(`>> calcRange()`)
      
      const startInt = parseInt(start);
      const stopInt = parseInt(stop);
      const step = 1;

      let newArr = Array.from({ length: (stopInt - startInt) / step + 1 }, (_, i) => startInt + i * step);
      console.log(newArr)
      return newArr
    },
    calcToAndFromCounts(){
      console.log(`>> calcToAndFromCounts()`)

      this.pagination.fromCount = (parseInt(this.pagination.currentPage) * parseInt(this.pagination.numberPerPage) - parseInt(this.pagination.numberPerPage)) + 1;
      if (this.totalSearchResultCount >= this.pagination.numberPerPage){
        this.pagination.toCount = parseInt(this.pagination.currentPage) * parseInt(this.pagination.numberPerPage);
      } else {
        this.pagination.toCount = this.totalSearchResultCount;
      }
    },
    createSearchPayload() {
      console.log(`>> createSearchPayload()`)
      
      console.log(this)
      let payLoad = {
        "query": this.query,
        "from": parseInt(this.from),
        "size": parseInt(this.size),
        "sort": {
          "property": this.pagination.sortBy.field,
          "order": this.pagination.sortBy.direction
        }
      }

      console.log(`payload >>`)
      console.log(payLoad)
      return payLoad;
    },
    sortResults() {
      console.log(`>> sortResults()`)
      this.search();
    },
    handleNumberPerPageChange() {
      console.log(`>> numberPerPage(), ${this.pagination.numberPerPage}`)
      this.paginate();
    },
    handlePageChange(pageNum) {
      console.log(`>> handlePageChange() ${this.from}`);

      this.pagination.currentPage = pageNum;
      this.from = (parseInt(this.pagination.currentPage) * parseInt(this.pagination.numberPerPage)) - parseInt(this.pagination.numberPerPage);
      this.calcToAndFromCounts();
      console.log(`handlePageChange() ${this.from}`);
      console.log(this.pagination.currentPage)
      this.paginate();
    },
    handlePreviousWindowChange() {
      console.log(`>> handlePreviousWindowChange()`);
      const maxPageWindow = parseInt(this.pagination.maxPageWindow);
      this.pagination.currentPage -= maxPageWindow;
      this.pagination.startWindow -= maxPageWindow;
      this.pagination.endWindow -= maxPageWindow;
      this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
      this.calcToAndFromCounts();
      this.paginate();
    },
    handleNextWindowChange() {
      console.log(`>> handleNextWindowChange()`);

      const maxPageWindow = parseInt(this.pagination.maxPageWindow);
      this.pagination.currentPage += maxPageWindow;
      this.pagination.startWindow += maxPageWindow;
      this.pagination.endWindow += maxPageWindow;
      this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
      this.calcToAndFromCounts();
      this.paginate();
    },
    handlePreviousPageChange() {
      console.log(`>> handlePreviousPageChange()`);

      this.pagination.currentPage -=1;

      if ((this.pagination.currentPage < this.pagination.startWindow) && (this.pagination.currentPage >= 1)) {
        this.pagination.endWindow = this.pagination.currentPage;

        if (this.pagination.maxPageWindow - this.pagination.endWindow === 0) {
          this.pagination.startWindow = 1;
        } else if ((this.pagination.endWindow - this.pagination.maxPageWindow) >= 10) {
          this.pagination.startWindow -= this.pagination.maxPageWindow;
        }

        this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
      }

      this.calcToAndFromCounts();
      console.log(`handlePreviousWindowChange() >>`)
      console.log(this.pagination)

      this.paginate();
    },
    handleNextPageChange() {
      console.log(`>> handleNextPageChange()`);

      this.pagination.currentPage +=1;
      if ((this.pagination.currentPage > this.pagination.endWindow) && (this.pagination.currentPage <= this.pagination.totalPages)) {
        this.pagination.startWindow = this.pagination.currentPage;

        if (this.pagination.startWindow === this.pagination.totalPages) {
          this.pagination.endWindow = this.pagination.startWindow;
        } else if ((this.pagination.endWindow + this.pagination.maxPageWindow) < this.pagination.totalPages) {
          this.pagination.endWindow += this.pagination.maxPageWindow;
        } else if ((this.pagination.endWindow + this.pagination.maxPageWindow) > this.pagination.totalPages) {
          this.pagination.endWindow += (this.pagination.totalPages - this.pagination.startWindow);
        }

        this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
      }

      this.calcToAndFromCounts();
      console.log(this.pagination.currentPage, this.pagination.startWindow, this.pagination.endWindow)
      
      console.log(`getNextPage() >> `)
      console.log(this.pagination)

      this.paginate();
    }
  }
});