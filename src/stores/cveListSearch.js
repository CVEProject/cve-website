import { defineStore } from 'pinia';
import axios from 'axios';

export const useCveListSearchStore = defineStore('cveListSearch ', {
  state: () => { 
    return {
      cveId: '',
      from: 0,
      isArecord: undefined,
      isSeachButtonDisabled: true,
      isIdOrRecordFound: true,
      isPublished: false,
      isReserved: false,
      isRejected: false,
      isSearching: false,
      isLookingUpRecord: false,
      isQueryingSearchService: false,
      isLookUpRecordServerError: false,
      isSearchServerError: false,
      query: '',
      recordData: {},
      searchResults: [],
      serverError: false,
      showHelpText: false,
      size: 25,
      totalExecutingRequests: -1,
      totalSearchResultCount: 0,
      pagination: {
        startWindow: 1,
        endWindow: undefined,
        firstPage: 1,
        currentPage: 1,
        currentPageWindow: [],
        totalPages: undefined,
        maxPageWindow: 5,
        numberPerPage: 25,
        sortBy: {
          field: 'cveId',
          direction: 'desc',
          label: 'CVE ID (newest to oldest)',
          selected: true
        },
        sortByOptions: [
          {
            field: 'cveId',
            direction: 'desc',
            label: 'CVE ID (newest to oldest)',
            selected: true
          },
          {
            field: 'cveId',
            direction: 'asc',
            label: 'CVE ID (oldest to newest)',
            selected: false
          },
          {
            field: 'relevancy',
            direction: 'desc',
            label: 'Relevancy (most to least)',
            selected: false
          },
          {
            field: 'relevancy',
            direction: 'asc',
            label: 'Relevancy (least to most)',
            selected: false
          }
        ],
        numberPerPageOptions: [25, 50, 100, 200],
        fromCount: undefined,
        toCount: undefined
      },
    }
  },
  actions: {
    decrement(field) {
      this[field] -= 1;
    },
    isCveIdPattern() {
      return new RegExp(/^CVE-\d{4}-\d{4,7}$/, 'i').test(this.query);
    },
    async search() {
      console.log(`>> search()`)
      this.isSearching = true;
      try{

        console.log('search() >> about to call getSearchResults()')
        // * 2nd, query search service
        this.totalExecutingRequests = 1;
        await this.getSearchResults();
        console.log('search() >> just called getSearchResults()')

        // * Check if keyword is CVE ID
        if (this.isCveIdPattern()) {
          this.totalExecutingRequests = 2;
          
          // 1st, lookup ID to get Record data, and continue to get CVE Records that mention that ID
          this.cveId = this.query.toUpperCase();
          console.log('search() >> about to call getRecordData()')
          await this.getRecordData();
          console.log('search() >> just called getRecordData()')
        }

      } catch (error) {
         throw new Error('search() >> error with getRecordData() and or getSearchResults()');
      } finally {
        this.isSearching = false;
        this.setUpInitialPagination();
      }
    },
    async getRecordData() {
      console.log(`>> getRecordData()`)
      this.isLookingUpRecord = true;
      const getRecordUrl = `/api/cve/${this.cveId}`;
      console.log('getRecordData >> getRecordUrl: ', getRecordUrl);

      try {
        axios.defaults.baseURL = `https://${import.meta.env.VITE_CVE_SERVICES_BASE_URL}`;
        const response = await axios.get(getRecordUrl);
        const cveRecordData = response?.data || {};
        console.log('getRecordData >> typeof response: ', typeof response);
        console.log('getRecordData >> cveRecordData', cveRecordData);
        this.isArecord = true;
        this.isIdOrRecordFound = false;

        // format description
        let descriptions = [];
        cveRecordData.containers?.cna?.descriptions.forEach((description) => {
          if (this.isEnglishLanguage(description.lang)) descriptions.push(this.processShowMoreShowLessDescription(description.value));
        });
        let recordDataSummary = {
          cveId: cveRecordData?.cveMetadata?.cveId || 'No ID provided',
          cna: cveRecordData?.cveMetadata?.assignerShortName || 'No CNA provided',
          descriptions: descriptions,
          relevancyScore: 'not appliciable'
        }
        this.recordData = recordDataSummary;
        console.log('getRecordData >>  this.recordData = recordDataSummary ', recordDataSummary)

        if (cveRecordData?.cveMetadata.state === 'PUBLISHED') {
          this.isPublished = true;
        } else if (cveRecordData?.cveMetadata.state === 'REJECTED') {
          this.isRejected = true;
        }

      } catch (e) {
        console.log(`getRecordData >> Catch error: ${e}`);
        this.isLookUpRecordServerError = true;

        this.isPublished = false;
        this.isReserved = false;
        this.isRejected = false;
        this.isIdOrRecordFound = false;
        this.isArecord = false;
        throw new Error('getRecordData >> throwing wrroe')
      } finally {
        this.isLookingUpRecord = false;
        this.decrement('totalExecutingRequests');
        console.log(`getRecordData >> finally`);
      }
    },
    async getSearchResults() {
      console.log(`>> getSearchResults()`)
      this.isQueryingSearchService = true;

      const instance = axios.create({
        baseURL: import.meta.env.VITE_API_BASE_URL,
      });

      try {
        let payLoad = this.createSearchPayload();
        // const response = await instance.post(
        //   import.meta.env.VITE_LIST_SEARCH_PATH,
        //   payLoad
        // );

        const response = {
          status: 200,
          data: {
            // "resultsTotal": 10,
            // "resultsTotal": 256,
            // "resultsTotal": 276,
            "resultsTotal": 301,
            // "resultsTotal": 311,
            // "resultsTotal": 326,
            // "resultsTotal": 351,
            "data": [
                {
                    "_index": "cve-index-dev",
                    "_type": "_doc",
                    "_id": "CVE-2020-26254",
                    "_score": 12.473869,
                    "_source": {
                        "containers": {
                            "cna": {
                                "affected": [
                                    {
                                        "product": "omniauth-apple",
                                        "vendor": "nhosoya",
                                        "versions": [
                                            {
                                                "status": "affected",
                                                "version": "< 1.0.1"
                                            }
                                        ]
                                    }
                                ],
                                "descriptions": [
                                    {
                                        "lang": "en",
                                        "value": "omniauth-apple is the OmniAuth strategy for \"Sign In with Apple\" (RubyGem omniauth-apple). In omniauth-apple before version 1.0.1 attackers can fake their email address during authentication. This vulnerability impacts applications using the omniauth-apple strategy of OmniAuth and using the info.email field of OmniAuth's Auth Hash Schema for any kind of identification. The value of this field may be set to any value of the attacker's choice including email addresses of other users. Applications not using info.email for identification but are instead using the uid field are not impacted in the same manner. Note, these applications may still be negatively affected if the value of info.email is being used for other purposes. Applications using affected versions of omniauth-apple are advised to upgrade to omniauth-apple version 1.0.1 or later."
                                    }
                                ],
                                "metrics": [
                                    {
                                        "cvssV3_1": {
                                            "attackComplexity": "LOW",
                                            "attackVector": "NETWORK",
                                            "availabilityImpact": "NONE",
                                            "baseScore": 7.7,
                                            "baseSeverity": "HIGH",
                                            "confidentialityImpact": "NONE",
                                            "integrityImpact": "HIGH",
                                            "privilegesRequired": "LOW",
                                            "scope": "CHANGED",
                                            "userInteraction": "NONE",
                                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N",
                                            "version": "3.1"
                                        }
                                    }
                                ],
                                "problemTypes": [
                                    {
                                        "descriptions": [
                                            {
                                                "cweId": "CWE-290",
                                                "description": "CWE-290 Authentication Bypass by Spoofing",
                                                "lang": "en",
                                                "type": "CWE"
                                            }
                                        ]
                                    }
                                ],
                                "providerMetadata": {
                                    "dateUpdated": "2020-12-08T14:20:13",
                                    "orgId": "a0819718-46f1-4df5-94e2-005712e83aaa",
                                    "shortName": "GitHub_M"
                                },
                                "references": [
                                    {
                                        "tags": [
                                            "x_refsource_CONFIRM"
                                        ],
                                        "url": "https://github.com/nhosoya/omniauth-apple/security/advisories/GHSA-49r3-2549-3633"
                                    },
                                    {
                                        "tags": [
                                            "x_refsource_MISC"
                                        ],
                                        "url": "https://github.com/nhosoya/omniauth-apple/commit/b37d5409213adae2ca06a67fec14c8d3d07d9016"
                                    },
                                    {
                                        "tags": [
                                            "x_refsource_MISC"
                                        ],
                                        "url": "https://github.com/nhosoya/omniauth-apple/blob/master/CHANGELOG.md#101---2020-12-03"
                                    }
                                ],
                                "source": {
                                    "advisory": "GHSA-49r3-2549-3633",
                                    "discovery": "UNKNOWN"
                                },
                                "title": "omniauth-apple allows attacker to fake their email address during authentication",
                                "x_legacyV4Record": {
                                    "CVE_data_meta": {
                                        "ASSIGNER": "security-advisories@github.com",
                                        "ID": "CVE-2020-26254",
                                        "STATE": "PUBLIC",
                                        "TITLE": "omniauth-apple allows attacker to fake their email address during authentication"
                                    },
                                    "affects": {
                                        "vendor": {
                                            "vendor_data": [
                                                {
                                                    "product": {
                                                        "product_data": [
                                                            {
                                                                "product_name": "omniauth-apple",
                                                                "version": {
                                                                    "version_data": [
                                                                        {
                                                                            "version_value": "< 1.0.1"
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    },
                                                    "vendor_name": "nhosoya"
                                                }
                                            ]
                                        }
                                    },
                                    "data_format": "MITRE",
                                    "data_type": "CVE",
                                    "data_version": "4.0",
                                    "description": {
                                        "description_data": [
                                            {
                                                "lang": "eng",
                                                "value": "omniauth-apple is the OmniAuth strategy for \"Sign In with Apple\" (RubyGem omniauth-apple). In omniauth-apple before version 1.0.1 attackers can fake their email address during authentication. This vulnerability impacts applications using the omniauth-apple strategy of OmniAuth and using the info.email field of OmniAuth's Auth Hash Schema for any kind of identification. The value of this field may be set to any value of the attacker's choice including email addresses of other users. Applications not using info.email for identification but are instead using the uid field are not impacted in the same manner. Note, these applications may still be negatively affected if the value of info.email is being used for other purposes. Applications using affected versions of omniauth-apple are advised to upgrade to omniauth-apple version 1.0.1 or later."
                                            }
                                        ]
                                    },
                                    "impact": {
                                        "cvss": {
                                            "attackComplexity": "LOW",
                                            "attackVector": "NETWORK",
                                            "availabilityImpact": "NONE",
                                            "baseScore": 7.7,
                                            "baseSeverity": "HIGH",
                                            "confidentialityImpact": "NONE",
                                            "integrityImpact": "HIGH",
                                            "privilegesRequired": "LOW",
                                            "scope": "CHANGED",
                                            "userInteraction": "NONE",
                                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:H/A:N",
                                            "version": "3.1"
                                        }
                                    },
                                    "problemtype": {
                                        "problemtype_data": [
                                            {
                                                "description": [
                                                    {
                                                        "lang": "eng",
                                                        "value": "CWE-290 Authentication Bypass by Spoofing"
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    "references": {
                                        "reference_data": [
                                            {
                                                "name": "https://github.com/nhosoya/omniauth-apple/security/advisories/GHSA-49r3-2549-3633",
                                                "refsource": "CONFIRM",
                                                "url": "https://github.com/nhosoya/omniauth-apple/security/advisories/GHSA-49r3-2549-3633"
                                            },
                                            {
                                                "name": "https://github.com/nhosoya/omniauth-apple/commit/b37d5409213adae2ca06a67fec14c8d3d07d9016",
                                                "refsource": "MISC",
                                                "url": "https://github.com/nhosoya/omniauth-apple/commit/b37d5409213adae2ca06a67fec14c8d3d07d9016"
                                            },
                                            {
                                                "name": "https://github.com/nhosoya/omniauth-apple/blob/master/CHANGELOG.md#101---2020-12-03",
                                                "refsource": "MISC",
                                                "url": "https://github.com/nhosoya/omniauth-apple/blob/master/CHANGELOG.md#101---2020-12-03"
                                            }
                                        ]
                                    },
                                    "source": {
                                        "advisory": "GHSA-49r3-2549-3633",
                                        "discovery": "UNKNOWN"
                                    }
                                }
                            }
                        },
                        "cveMetadata": {
                            "assignerOrgId": "a0819718-46f1-4df5-94e2-005712e83aaa",
                            "assignerShortName": "GitHub_M",
                            "cveId": "CVE-2020-26254",
                            "datePublished": "2020-12-08T14:20:13",
                            "dateReserved": "2020-10-01T00:00:00",
                            "dateUpdated": "2020-12-08T14:20:13",
                            "state": "PUBLISHED"
                        },
                        "dataType": "CVE_RECORD",
                        "dataVersion": "5.0"
                    }
                },
                {
                    "_index": "cve-index-dev",
                    "_type": "_doc",
                    "_id": "CVE-2014-2234",
                    "_score": 11.627534,
                    "_source": {
                        "containers": {
                            "cna": {
                                "affected": [
                                    {
                                        "product": "n/a",
                                        "vendor": "n/a",
                                        "versions": [
                                            {
                                                "status": "affected",
                                                "version": "n/a"
                                            }
                                        ]
                                    }
                                ],
                                "datePublic": "2014-03-03T00:00:00",
                                "descriptions": [
                                    {
                                        "lang": "en",
                                        "value": "A certain Apple patch for OpenSSL in Apple OS X 10.9.2 and earlier uses a Trust Evaluation Agent (TEA) feature without terminating certain TLS/SSL handshakes as specified in the SSL_CTX_set_verify callback function's documentation, which allows remote attackers to bypass extra verification within a custom application via a crafted certificate chain that is acceptable to TEA but not acceptable to that application."
                                    }
                                ],
                                "problemTypes": [
                                    {
                                        "descriptions": [
                                            {
                                                "description": "n/a",
                                                "lang": "en",
                                                "type": "text"
                                            }
                                        ]
                                    }
                                ],
                                "providerMetadata": {
                                    "dateUpdated": "2014-03-05T02:57:00",
                                    "orgId": "8254265b-2729-46b6-b9e3-3dfca2d5bfca",
                                    "shortName": "mitre"
                                },
                                "references": [
                                    {
                                        "tags": [
                                            "x_refsource_MISC"
                                        ],
                                        "url": "https://hynek.me/articles/apple-openssl-verification-surprises/"
                                    }
                                ],
                                "x_legacyV4Record": {
                                    "CVE_data_meta": {
                                        "ASSIGNER": "cve@mitre.org",
                                        "ID": "CVE-2014-2234",
                                        "STATE": "PUBLIC"
                                    },
                                    "affects": {
                                        "vendor": {
                                            "vendor_data": [
                                                {
                                                    "product": {
                                                        "product_data": [
                                                            {
                                                                "product_name": "n/a",
                                                                "version": {
                                                                    "version_data": [
                                                                        {
                                                                            "version_value": "n/a"
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    },
                                                    "vendor_name": "n/a"
                                                }
                                            ]
                                        }
                                    },
                                    "data_format": "MITRE",
                                    "data_type": "CVE",
                                    "data_version": "4.0",
                                    "description": {
                                        "description_data": [
                                            {
                                                "lang": "eng",
                                                "value": "A certain Apple patch for OpenSSL in Apple OS X 10.9.2 and earlier uses a Trust Evaluation Agent (TEA) feature without terminating certain TLS/SSL handshakes as specified in the SSL_CTX_set_verify callback function's documentation, which allows remote attackers to bypass extra verification within a custom application via a crafted certificate chain that is acceptable to TEA but not acceptable to that application."
                                            }
                                        ]
                                    },
                                    "problemtype": {
                                        "problemtype_data": [
                                            {
                                                "description": [
                                                    {
                                                        "lang": "eng",
                                                        "value": "n/a"
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    "references": {
                                        "reference_data": [
                                            {
                                                "name": "https://hynek.me/articles/apple-openssl-verification-surprises/",
                                                "refsource": "MISC",
                                                "url": "https://hynek.me/articles/apple-openssl-verification-surprises/"
                                            }
                                        ]
                                    }
                                }
                            }
                        },
                        "cveMetadata": {
                            "assignerOrgId": "8254265b-2729-46b6-b9e3-3dfca2d5bfca",
                            "assignerShortName": "mitre",
                            "cveId": "CVE-2014-2234",
                            "datePublished": "2014-03-05T02:00:00",
                            "dateReserved": "2014-02-28T00:00:00",
                            "dateUpdated": "2014-03-05T02:57:00",
                            "state": "PUBLISHED"
                        },
                        "dataType": "CVE_RECORD",
                        "dataVersion": "5.0"
                    }
                },
                {
                    "_index": "cve-index-dev",
                    "_type": "_doc",
                    "_id": "CVE-2020-9982",
                    "_score": 11.247124,
                    "_source": {
                        "containers": {
                            "cna": {
                                "affected": [
                                    {
                                        "product": "Apple Music for Android",
                                        "vendor": "Apple",
                                        "versions": [
                                            {
                                                "lessThan": "3.4",
                                                "status": "affected",
                                                "version": "unspecified",
                                                "versionType": "custom"
                                            }
                                        ]
                                    }
                                ],
                                "descriptions": [
                                    {
                                        "lang": "en",
                                        "value": "This issue was addressed with improved checks to prevent unauthorized actions. This issue is fixed in Apple Music 3.4.0 for Android. A malicious application may be able to leak a user's credentials."
                                    }
                                ],
                                "problemTypes": [
                                    {
                                        "descriptions": [
                                            {
                                                "description": "A malicious application may be able to leak a user's credentials",
                                                "lang": "en",
                                                "type": "text"
                                            }
                                        ]
                                    }
                                ],
                                "providerMetadata": {
                                    "dateUpdated": "2020-10-27T20:53:09",
                                    "orgId": "286789f9-fbc2-4510-9f9a-43facdede74c",
                                    "shortName": "apple"
                                },
                                "references": [
                                    {
                                        "tags": [
                                            "x_refsource_MISC"
                                        ],
                                        "url": "https://support.apple.com/en-us/HT211898"
                                    }
                                ],
                                "x_legacyV4Record": {
                                    "CVE_data_meta": {
                                        "ASSIGNER": "product-security@apple.com",
                                        "ID": "CVE-2020-9982",
                                        "STATE": "PUBLIC"
                                    },
                                    "affects": {
                                        "vendor": {
                                            "vendor_data": [
                                                {
                                                    "product": {
                                                        "product_data": [
                                                            {
                                                                "product_name": "Apple Music for Android",
                                                                "version": {
                                                                    "version_data": [
                                                                        {
                                                                            "version_affected": "<",
                                                                            "version_value": "3.4"
                                                                        }
                                                                    ]
                                                                }
                                                            }
                                                        ]
                                                    },
                                                    "vendor_name": "Apple"
                                                }
                                            ]
                                        }
                                    },
                                    "data_format": "MITRE",
                                    "data_type": "CVE",
                                    "data_version": "4.0",
                                    "description": {
                                        "description_data": [
                                            {
                                                "lang": "eng",
                                                "value": "This issue was addressed with improved checks to prevent unauthorized actions. This issue is fixed in Apple Music 3.4.0 for Android. A malicious application may be able to leak a user's credentials."
                                            }
                                        ]
                                    },
                                    "problemtype": {
                                        "problemtype_data": [
                                            {
                                                "description": [
                                                    {
                                                        "lang": "eng",
                                                        "value": "A malicious application may be able to leak a user's credentials"
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                    "references": {
                                        "reference_data": [
                                            {
                                                "name": "https://support.apple.com/en-us/HT211898",
                                                "refsource": "MISC",
                                                "url": "https://support.apple.com/en-us/HT211898"
                                            }
                                        ]
                                    }
                                }
                            }
                        },
                        "cveMetadata": {
                            "assignerOrgId": "286789f9-fbc2-4510-9f9a-43facdede74c",
                            "assignerShortName": "apple",
                            "cveId": "CVE-2020-9982",
                            "datePublished": "2020-10-27T20:53:09",
                            "dateReserved": "2020-03-02T00:00:00",
                            "dateUpdated": "2020-10-27T20:53:09",
                            "state": "PUBLISHED"
                        },
                        "dataType": "CVE_RECORD",
                        "dataVersion": "5.0"
                    }
                }
            ]
        }
        }

        console.log('getSearchResults >> Search service response:', response);

        if (response.status === 200) {
          this.totalSearchResultCount = response.data.resultsTotal;
          console.log('getSearchResults >>> axios request competed successfully, totalSearchResultCount: ', this.totalSearchResultCount)
          this.processSearchResults(response.data.data);
        }

      } catch (e) {
        this.isSearchServerError = true;
        console.log('getSearchResults >> catch error : ', e);
        throw new Error(`getSearchResults >> : ${e}`)
      } finally {
        this.isQueryingSearchService = false;
        this.decrement('totalExecutingRequests');
        console.log(`getSearchResults >> finally`)
      }
    },
    processSearchResults(results){
      console.log(`>> processSearchResults()`)
      const parsedResults = [];

      if (results.length >> 0) {
        results.forEach((result) => {

          parsedResults.push({
            cveId: result._id,
            cna: result?._source?.cveMetadata?.assignerShortName || 'No CNA provided',
            descriptions: this.processDescriptionsField(result),
            relevancyScore: result?._score
          });
        });
      }

      this.searchResults = parsedResults;
    },
    processDescriptionsField(result){
      let descriptions = [];
      if (result?._source?.cveMetadata?.state === "PUBLISHED") {
        result?._source?.containers?.cna?.descriptions.forEach((description) => {
          if (this.isEnglishLanguage(description.lang)) descriptions.push(this.processShowMoreShowLessDescription(description.value));
        });
      } else if (result?._source?.cveMetadata?.state === "REJECTED") {
        result?._source?.containers?.cna?.rejectedReasons.forEach((rejectedReason) => {
          if (this.isEnglishLanguage(rejectedReason.lang)) descriptions.push(this.processShowMoreShowLessDescription(rejectedReason.value));
        });
      } else {
        descriptions.push('No description provided');
      }

      return descriptions;
    },
    processShowMoreShowLessDescription(description){
      let words = this.splitDescriptionsIntoWords(description);
      let processedDescription = {
        firstChunk: words.splice(0, 30).join(' '),
        secondChunk: words.join(' '),
        showMore: false,
      };

      return processedDescription;
      // if 1st or 2nd arr empty then don't display
    },
    splitDescriptionsIntoWords(str) {
      const value = str.trim()
      if(!value) return 0;
      return value.split(/\s+/);
    },
    setUpInitialPagination() {
      console.log('>> setUpInitialPagination ', this.pagination)
      if (Object.keys(this.pagination.currentPageWindow).length === 0 && this.totalSearchResultCount > 0) {
        // sets up these values for the first search request and the rest is handled in SearchResults component
        this.pagination.totalPages = Math.ceil(this.totalSearchResultCount / this.pagination.numberPerPage);
        if (this.pagination.totalPages < this.pagination.maxPageWindow) {
          this.pagination.endWindow = this.pagination.maxPageWindow = this.pagination.totalPages;
        } else {
          this.pagination.endWindow = this.pagination.maxPageWindow;
        }

        this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
        this.calcToAndFromCounts();
        console.log('setUpInitialPagination >> after ', this.pagination)
      }
    },
    async paginate() {
      try {
        console.log(`>> paginate()`)
        this.calcToAndFromCounts();
      
        // search service starts at 0 while this app starts at 1
        this.from = (parseInt(this.pagination.currentPage) * parseInt(this.pagination.numberPerPage)) - parseInt(this.pagination.numberPerPage);
        if (parseInt(this.from) + parseInt(this.pagination.numberPerPage) > parseInt(this.totalSearchResultCount)) {
          this.size = parseInt(this.totalSearchResultCount) - parseInt(this.from);
        } else {
          this.size = parseInt(this.pagination.numberPerPage);
        }
        console.log(`paginate() >> ${this.from}, ${this.size}`);
        console.log(this.pagination);

        await this.search();
      } finally {
        this.router.push({
          name: 'SearchResults',
          query: {query: this.query},
          replace: true
        });
      }
    },
    calcRange(start, stop) {
      console.log(`>> calcRange()`)
      
      const startInt = parseInt(start);
      const stopInt = parseInt(stop);
      const step = 1;

      let newArr = Array.from({ length: (stopInt - startInt) / step + 1 }, (_, i) => startInt + i * step);
      console.log(newArr)
      return newArr
    },
    calcToAndFromCounts(){
      console.log(`>> calcToAndFromCounts()`)

      this.pagination.fromCount = (parseInt(this.pagination.currentPage) * parseInt(this.pagination.numberPerPage) - parseInt(this.pagination.numberPerPage)) + 1;
      if (this.totalSearchResultCount >= (this.pagination.numberPerPage * this.pagination.currentPage)){
        this.pagination.toCount = parseInt(this.pagination.currentPage) * parseInt(this.pagination.numberPerPage);
      } else if (this.pagination.fromCount === this.totalSearchResultCount) {
        this.pagination.toCount = undefined;
      } else {
        this.pagination.toCount = this.totalSearchResultCount;
      }
    },
    createSearchPayload() {
      console.log(`>> createSearchPayload()`)
      
      console.log(this)
      let payLoad = {
        "query": this.query,
        "from": parseInt(this.from),
        "size": parseInt(this.size),
        "sort": {
          "property": this.pagination.sortBy.field,
          "order": this.pagination.sortBy.direction
        }
      }

      console.log(`payload >>`)
      console.log(payLoad)
      return payLoad;
    },
    getResults() {
      this.pagination.currentPage = 1;
      this.paginate();

      this.pagination.totalPages = Math.ceil(this.totalSearchResultCount / this.pagination.numberPerPage);
      if (this.pagination.totalPages < this.pagination.maxPageWindow) {
        this.pagination.endWindow = this.pagination.totalPages;
      } else {
        this.pagination.endWindow = this.pagination.maxPageWindow;
      }

      this.pagination.currentPageWindow = this.calcRange(1, this.pagination.endWindow);
      this.calcToAndFromCounts();
    },
    sortResults() {
      console.log(`>> sortResults()`)
      this.getResults();
    },
    handleNumberPerPageChange() {
      console.log(`>> numberPerPage(), ${this.pagination.numberPerPage}`)
      this.getResults();
    },
    handlePageChange(pageNum) {
      console.log(`>> handlePageChange() ${this.from}`);

      this.pagination.currentPage = pageNum;
      this.paginate();
    },
    handlePreviousWindowChange() {
      console.log(`>> handlePreviousWindowChange()`);
      const maxPageWindow = parseInt(this.pagination.maxPageWindow);
      const isPartialWindow = (parseInt(this.pagination.endWindow) % maxPageWindow) > 0;
      this.pagination.currentPage = parseInt(this.pagination.currentPage) - maxPageWindow;
      this.pagination.startWindow = parseInt(this.pagination.startWindow) - maxPageWindow;
      this.pagination.endWindow = isPartialWindow ? (this.pagination.startWindow + (maxPageWindow - 1)) : this.pagination.endWindow - maxPageWindow;
      this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
      this.paginate();
    },
    handleNextWindowChange() {
      console.log(`>> handleNextWindowChange()`);
      const maxPageWindow = parseInt(this.pagination.maxPageWindow);
      const totalPages = parseInt(this.pagination.totalPages);
      const endWindow = parseInt(this.pagination.endWindow);
      const isPartialWindow = (totalPages - (endWindow + maxPageWindow)) < 0;
      const currentPageExceedsMaxPage = (this.pagination.currentPage + maxPageWindow) > totalPages;
      const partialWindowSize =  totalPages % maxPageWindow;

      this.pagination.currentPage = isPartialWindow && currentPageExceedsMaxPage ? totalPages : this.pagination.currentPage + maxPageWindow;
      this.pagination.startWindow = parseInt(this.pagination.startWindow) + maxPageWindow;
      this.pagination.endWindow = isPartialWindow ? endWindow + partialWindowSize : endWindow + maxPageWindow;
      this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
      this.paginate();
    },
    handlePreviousPageChange() {
      console.log(`>> handlePreviousPageChange()`);

      this.pagination.currentPage = parseInt(this.pagination.currentPage) - 1;

      if (this.pagination.currentPage >= 1) {
        if (this.pagination.currentPage % this.pagination.maxPageWindow === 0) {
          this.pagination.endWindow = parseInt(this.pagination.currentPage);
          this.pagination.startWindow = parseInt(this.pagination.endWindow) - (parseInt(this.pagination.maxPageWindow) - 1);
        }

        this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
        this.paginate();
      } 
    },
    handleNextPageChange() {
      console.log(`>> handleNextPageChange()`);

      this.pagination.currentPage = parseInt(this.pagination.currentPage) + 1;
      if ((this.pagination.currentPage > this.pagination.endWindow) && (this.pagination.currentPage <= this.pagination.totalPages)) {
        this.pagination.startWindow = this.pagination.currentPage;

        if (this.pagination.startWindow === this.pagination.totalPages) {
          this.pagination.endWindow = this.pagination.startWindow;
        } else if ((this.pagination.endWindow + this.pagination.maxPageWindow) < this.pagination.totalPages) {
          this.pagination.endWindow = parseInt(this.pagination.endWindow) + this.pagination.maxPageWindow;
        } else if ((this.pagination.endWindow + this.pagination.maxPageWindow) > this.pagination.totalPages) {
          this.pagination.endWindow = parseInt(this.pagination.endWindow) + (this.pagination.totalPages - this.pagination.startWindow);
        }

        this.pagination.currentPageWindow = this.calcRange(this.pagination.startWindow, this.pagination.endWindow);
      }

      this.paginate();
    },
    handleShowMoreChange(resultIndex, descriptionIndex) {
      if (typeof resultIndex === 'number') {
        let description =  this.searchResults[resultIndex].descriptions[descriptionIndex];
        description.showMore = !description.showMore;
      } else {
        let description =  this.recordData.descriptions[descriptionIndex];
        description.showMore = !description.showMore;
      }
    },
    isEnglishLanguage(lang) {
      const regex = /^(en)/;
      const isEnglishLanguage = regex.test(lang);

      return isEnglishLanguage;
    },
  }
});