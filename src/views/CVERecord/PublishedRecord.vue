<template>
  <div class="content">
    <nav class="level mb-0">
      <div class="level-left">
        <div class="level-item">
          <h1 class="title">{{useCveRecordLookupStore.cveId}}</h1>
        </div>
        <div v-if="cveFieldList.state.length > 0" class="level-item">
          <span class="tag is-info is-light has-text-weight-bold cve-state-tag">{{cveFieldList.state}}</span>
        </div>
      </div>
      <div class="level-right ml-1">
        <div class="level-item">
          <span class="icon-text">
            <a id="cve-view-json" :href="`https://${cveServicesBaseUrl}/api/cve/${useCveRecordLookupStore.cveId}`" target="_blank">
              <span class="icon">
                <p id="enewsletter" class="is-hidden">external site</p>
                <font-awesome-icon icon="file-code" aria-labelledby="enewsletter"></font-awesome-icon>
              </span>
              View JSON
            </a>
          </span>
        </div>
        <div class="level-item is-hidden-mobile">
          |
        </div>
        <div class="level-item">
          <span class="icon-text">
            <router-link to="/CVERecord/UserGuide">
              <span class="icon">
                <p id="enewsletter" class="is-hidden">external site</p>
                <font-awesome-icon icon="book" aria-labelledby="enewsletter"></font-awesome-icon>
              </span>
              User Guide
            </router-link>
          </span>
        </div>
      </div>
    </nav>
    <hr/>
    <nav class="level mb-0 is-mobile">
      <div class="level-left">
        <div class="level-item">
          <h2 class="title">Data by Provider</h2>
        </div>
      </div>
      <div class="level-right ml-1">
        <div class="level-item">
          <div id="cve-accordian-expand-collapse-all-btn" class="buttons mb-0" style="justify-content: flex-end;">
        <button id="expand-collpse-all-btn" @click="toggleAccordian" class="button cve-button"
        >
          {{ useCveRecordLookupStore.accordianState.collapseAll ? 'Collapse' : 'Expand' }} all
        </button>
      </div>
        </div>
      </div>
    </nav>
    <div id="cve-containers" class="mt-2">
      <AdpVulnerabilityEnrichment v-if="Object.keys(cnaContainer).length > 0"  id="cve-cna-container" role="cna" :selectedCnaData="cveFieldList"
        :containerObject="cnaContainer" :orgId="cnaContainer.providerMetadata.orgId"
      >
        <h3 class="title mb-1">CNA</h3>
      </AdpVulnerabilityEnrichment>
      <!-- <AdpVulnerabilityEnrichment v-if="!useCveRecordLookupStore.hasHistoricalReferences" id="cve-cna-container" role="cna" :containerObject="cnaContainer"></AdpVulnerabilityEnrichment> -->
      <AdpVulnerabilityEnrichment v-if="Object.keys(secretariatContainer).length > 0"  id="cve-secretariat-container" role="secretariat" 
        :selectedCnaData="{}" :containerObject="secretariatContainer" :orgId="secretariatContainer.providerMetadata.orgId"
      >
        <h3 class="title mb-1">CVE Program</h3>
      </AdpVulnerabilityEnrichment>
      <div class="cve-adp-container" v-for="adpContainer in adpContainers" :key="adpContainer.key">
        <AdpVulnerabilityEnrichment role="adp" :selectedCnaData="{}" :containerObject="adpContainer"
          :orgId="adpContainer.providerMetadata.orgId"
        >
          <h3 class="title mb-1">{{ adpContainer.providerMetadata.shortName }}</h3>
        </AdpVulnerabilityEnrichment>
        <!-- <div v-for="(adpContainer) in cveFieldList.productsStatus.adp" :key="adpContainer.key"
          class="mt-5"
        >
          <ProductStatus role="adp" :productStatusList="adpContainer"></ProductStatus>
        </div> -->
      </div>
    </div>
  </div> 
</template>

<script>
import _ from 'lodash';
import axios from 'axios';
import AdpVulnerabilityEnrichment from '@/components/AdpVulnerabilityEnrichment.vue';
import { useCveRecordLookupStore } from '@/stores/cveRecordLookup.ts';

export default {
  name: 'PublishedRecord',
  components: {
    AdpVulnerabilityEnrichment
  },
  props: {
    NVDBaseUrl: {
      type: String,
      required: true,
    }
  },
  data() {
    return {
      isMessageExpanded: false,
      isHelpTestShown: false,
      cveRecordFields: ['ID', 'CNA', 'Credits', 'Description', 'References', 'State', 'Tags', 'Title', 'VendorsProductsVersions',
        'RecordPublishedDate', 'RecordUpdatedDate'],
      cveFieldList: {
        cveId: '',
        credits: [],
        descriptions: [],
        productsStatus: {
          cna: [],
          adp: {}
        },
        title: '',
        state: '',
        assigner: '',
        dateUpdatedCveMetadata: '',
        datePublishedCveMetadata: '',
        references: [],
        tags: [],
      },
      originalRecordData: useCveRecordLookupStore().recordData || {},
      cveServicesBaseUrl: import.meta.env.VITE_CVE_SERVICES_BASE_URL,
      useCveRecordLookupStore: useCveRecordLookupStore(),
      cpe: {},
      cnaContainer: {},
      secretariatContainer: {},
      adpContainers: {},
    };
  },
  methods: {
    toggleAccordian() {
      const newPanelState = !useCveRecordLookupStore().accordianState.collapseAll;
      Object.keys(useCveRecordLookupStore().accordianState).forEach( (panelName) => {
        useCveRecordLookupStore().accordianState[panelName] = newPanelState;
      });
    },
    getContainersAndPopulateAccordionState() {
      this.cnaContainer = this.originalRecordData.containers.cna;
      if (this.cnaContainer?.providerMetadata?.orgId) {
        useCveRecordLookupStore().accordianState[this.cnaContainer.providerMetadata.orgId] = true;
      }
      if (this.originalRecordData?.containers?.adp) {
        this.originalRecordData.containers.adp.forEach((adp) => {
          if (adp.providerMetadata.shortName === 'Secretariat-ADP') {
            this.secretariatContainer = adp;
            useCveRecordLookupStore().accordianState[adp.providerMetadata.orgId] = true;
          } else {
            this.adpContainers[adp.providerMetadata.shortName] = adp;
            useCveRecordLookupStore().accordianState[adp.providerMetadata.orgId] = false;
          }
        });
      }
    },
    initializeFields() {
      this.cveRecordFields.forEach((field) => {
        this.getContentForField(field);
      });
    },
    getCNA() {
      const assignerShortName = this.originalRecordData?.cveMetadata?.assignerShortName;
      const partnerUUID = this.originalRecordData?.cveMetadata?.assignerOrgId;

      if (this.hasData(assignerShortName)) {
        const url = `${import.meta.env.VITE_API_BASE_URL}cve-partner-name-map.json`;
        axios
          .get(url, { timeout: 30000 })
          .then((response) => {
            const shortLongNameMap = response.data;
            if (shortLongNameMap?.[partnerUUID]) {
              this.cveFieldList.assigner = shortLongNameMap?.[partnerUUID];
            }
          })
          .finally(() => {
            if (this.cveFieldList.assigner.length === 0) {
              this.cveFieldList.assigner = assignerShortName.replace('_', ' ');
            }
          });
      }
    },
    getCredits() {
      // schema: https://github.com/CVEProject/cve-schema/blob/master/schema/v5.0/CVE_JSON_5.0_schema.json#L971-L1015
      const value = this.originalRecordData.containers?.cna?.credits;
      if (this.hasData(value)) {
        value.forEach((credit) => {
          if (this.isEnglishLanguage(credit.lang)) {
            this.cveFieldList.credits.push(credit);
          }
        });
      }
    },
    getRecordPublishedDate() {
      const value = this.originalRecordData.cveMetadata?.datePublished;
      if (this.hasData(value)) {
        this.cveFieldList.datePublishedCveMetadata = this.getDate(value);
      }
    },
    getRecordUpdatedDate() {
      const value = this.originalRecordData.cveMetadata?.dateUpdated;
      if (this.hasData(value)) {
        this.cveFieldList.dateUpdatedCveMetadata = this.getDate(value);
      }
    },
    getCVEid() {
      const value = this.originalRecordData.cveMetadata?.cveId;
      if (this.hasData(value)) {
        this.cveFieldList.cveId = value;
      } else {
        this.cveFieldList.cveId = useCveRecordLookupStore().recordData.cveMetadata.cveId; // user-provided CVE ID
      }
    },
    getDescription() {
      const value = this.originalRecordData.containers?.cna?.descriptions;
      if (this.hasData(value)) {
        value.forEach((desc) => {
          if (this.isEnglishLanguage(desc.lang)) {
            this.cveFieldList.descriptions.push(desc.value);
          }
        });
      }
    },
    getReferences() {
      const value = this.originalRecordData.containers?.cna?.references;
      if (this.hasData(value)) {
        const filteredReferences = [];
        const regex = /^x_refsource/;

        value.forEach((reference) => {
          let newReference = {};
          const filteredTags = [];

          if (reference?.tags) {
            reference.tags.forEach((tag) => {
              if (!regex.test(tag)) filteredTags.push(tag);
            });
          }
          newReference = _.cloneDeep(reference);
          newReference.tags = filteredTags;
          if (newReference?.name && newReference.name.length > 0) newReference.hostname = (new URL(newReference.url)).hostname.replace('www.', '');
          filteredReferences.push(newReference);
        });

        this.cveFieldList.references = filteredReferences;
      }
    },
    getState() {
      const value = this.originalRecordData.cveMetadata?.state;
      if (this.hasData(value)) {
        this.cveFieldList.state = value;
      }
    },
    getTags() {
      const value = this.originalRecordData.containers?.cna?.tags;
      if (this.hasData(value)) {
        this.cveFieldList.tags = value;
      }
    },
    getTitle() {
      const value = this.originalRecordData.containers?.cna?.title;
      if (this.hasData(value)) {
        this.cveFieldList.title = value;
      }
    },
    // getProductsStatus() is adapted from https://github.com/Vulnogram/seaview/blob/main/script.js#L140-L253
    getProductsStatus(containerName, containerAffectedList) {
      const affectedList = containerAffectedList;

      if(containerName.toLowerCase() !== 'cna') {
        useCveRecordLookupStore().hasAdpInfo = true;
      }

      if (this.hasData(affectedList)) {
        const prodStatusTemplate = {
          vendor: '',
          product: '',
          platforms: [],
          cpes: [],
          defaultStatus: '',
          versionsColumns: [],
        };

        /**
          Building the Product Status table each product in containers.cna.affected[]:
          - column 1: vendor, product, platforms, cpes
          - column 2: affected/unaffected/unknown list(s)/subcomlumn(s)
        */
        affectedList.forEach((affectedObj) => {
          const prodStatus = _.cloneDeep(prodStatusTemplate);
          // Building column 1
          if (this.hasData(affectedObj?.vendor)) prodStatus.vendor = affectedObj.vendor;
          if (this.hasData(affectedObj?.product)) prodStatus.product = affectedObj.product;
          if (this.hasData(affectedObj?.platforms)) prodStatus.platforms = _.cloneDeep(affectedObj.platforms);
          if (this.hasData(affectedObj?.cpes)) { 
            prodStatus.cpes = affectedObj.cpes;
          }

          // Building column 2: an affected/unaffected/unknown subcolumn(s) for each product version in containers.cna.affected[i].versions[].
          const versionsColumns = [];
          // https://github.com/Vulnogram/seaview/blob/main/script.js#L175-L216
          if (this.hasData(affectedObj?.versions)) {
            const tableRowTemplate = {
              versionRange: {
                parentVersion: [],
                parentVersionRange: [],
                parentVersionStatus: '',
                versionsChanges: [],
              },
            };

            affectedObj.versions.forEach((versionObj) => {
              const tableRow = _.cloneDeep(tableRowTemplate);
              const versionsAndChangesTemplate = {
                versions: [],
                changes: [],
                changeColorList: [],
              };
              const productVersion = `${versionObj?.version || '(no version provided)'}`;
              const versionStatus = versionObj?.status || 'noVersionStatus'; // affected, unaffected, OR unknown

              if (this.hasData(versionObj?.changes)) {
                let range = [];

                if (productVersion !== 'unspecified' && productVersion !== 0) {
                  range.push('from');
                  range.push(productVersion);
                }

                if (versionObj?.lessThan) {
                  let rangeEnd = ['before', `${versionObj?.lessThan || '(no lessThan version provided)'}`];
                  if (this.isUnspecifiedOrWildCard(versionObj, 'lessThan')) rangeEnd = [];
                  if ((rangeEnd.length > 0) && (versionObj.lessThan !== productVersion)) {
                    range = range.concat(rangeEnd);
                  }
                } else if (versionObj?.lessThanOrEqual) {
                  let rangeEnd = ['through', `${versionObj?.lessThanOrEqual || '(no lessThan version provided)'}`];
                  if (this.isUnspecifiedOrWildCard(versionObj, 'lessThanOrEqual')) rangeEnd = '';
                  if ((rangeEnd.length > 0) && (versionObj.lessThanOrEqual !== productVersion)) {
                    range = range.concat(rangeEnd);
                  }
                } else {
                  range = [productVersion];
                }

                // save the version changes
                const versionsAndChangesCopy = _.cloneDeep(versionsAndChangesTemplate);

                // Build a temp 'changes' object by going through container.cna.affected[x].versions[x].changes[]
                //   and categorize by 'status' (affected, unaffected, or unknown)
                //   which can be different from the main 'status' (container.cna.affected[x].versions[x].status).
                versionObj.changes.forEach((change) => {
                  versionsAndChangesCopy.changeColorList.push([change.status, 'from', change.at]);
                });

                tableRow.versionRange.parentVersionStatus = versionStatus;
                tableRow.versionRange.parentVersion = ['from', productVersion];
                tableRow.versionRange.parentVersionRange = range;
                tableRow.versionRange.versionsChanges = versionsAndChangesCopy.changeColorList;
              } else {
                let rangeStart = [];
                if (productVersion !== 'unspecified' && productVersion !== '*') rangeStart = ['from', productVersion];

                tableRow.versionRange.parentVersion = [productVersion];
                if (this.hasData(versionObj?.lessThan)) {
                  let range = [];
                  let rangeEnd = ['before', `${versionObj?.lessThan || '(no version.lessThan provided)'}`];
                  if (this.isUnspecifiedOrWildCard(versionObj, 'lessThan')) rangeEnd = [];
                  if (rangeEnd.length > 0) {
                    range = range.concat(rangeStart, rangeEnd);
                  } else {
                    range = rangeStart;
                  }
                  tableRow.versionRange.parentVersionStatus = versionStatus;
                  tableRow.versionRange.parentVersionRange = range;
                } else if (this.hasData(versionObj?.lessThanOrEqual)) {
                  let range = [];
                  let rangeEnd = ['through', `${versionObj?.lessThanOrEqual || '(no version.lessThan provided)'}`];
                  if (this.isUnspecifiedOrWildCard(versionObj, 'lessThanOrEqual')) rangeEnd = [];
                  range = range.concat(rangeStart, rangeEnd);
                  tableRow.versionRange.parentVersionStatus = versionStatus;
                  tableRow.versionRange.parentVersionRange = range;
                } else {
                  tableRow.versionRange.parentVersionStatus = versionStatus;
                  tableRow.versionRange.parentVersion = ['at', productVersion];
                  tableRow.versionRange.parentVersionRange = ['at', productVersion];
                }
              }
              versionsColumns.push(tableRow.versionRange);
            });

            if (this.hasData(affectedObj?.defaultStatus)) {
              prodStatus.defaultStatus = `${affectedObj.defaultStatus}`;
            }
          } else {
            prodStatus.defaultStatus = this.hasData(affectedObj?.defaultStatus) ? `All versions are ${affectedObj.defaultStatus}` : '';
          }
          prodStatus.versionsColumns = this.create2DTable(versionsColumns);
          if (containerName === 'cna') {
            this.cveFieldList.productsStatus[containerName].push(_.cloneDeep(prodStatus));
          } else {
            this.cveFieldList.productsStatus.adp[containerName] = [];
            this.cveFieldList.productsStatus.adp[containerName].push(_.cloneDeep(prodStatus));
          }
          
        });
      }
    },
    getContentForField(field) {
      switch (field) {
        case 'CNA':
          this.getCNA();
          break;
        case 'Credits':
          this.getCredits();
          break;
        case 'Description':
          this.getDescription();
          break;
        case 'ID':
          this.getCVEid();
          break;
        case 'RecordPublishedDate':
          this.getRecordPublishedDate();
          break;
        case 'RecordUpdatedDate':
          this.getRecordUpdatedDate();
          break;
        case 'References':
          this.getReferences();
          break;
        case 'State':
          this.getState();
          break;
        case 'Tags':
          this.getTags();
          break;
        case 'Title':
          this.getTitle();
          break;
        case 'VendorsProductsVersions':
          if (this.originalRecordData.containers?.cna?.affected) this.getProductsStatus('cna', this.originalRecordData.containers.cna.affected);
          if (this.originalRecordData.containers?.adp) {
            this.originalRecordData.containers.adp.forEach( (adpContainer) => {
              this.getProductsStatus(adpContainer.providerMetadata.shortName, adpContainer?.affected);
            });
          }
          break;
        default:
          break;
      }
    },
    hasData(value) {
      if (typeof value !== 'undefined' && value.length > 0) {
        return true;
      }

      return false;
    },
    isEnglishLanguage(lang) {
      const regex = /^(en)/;
      const isEnglishLanguage = regex.test(lang);

      return isEnglishLanguage;
    },
    isUnspecifiedOrWildCard(field, key) {
      return (field[key] === 'unspecified' || field[key] === '*');
    },
    getDate(dateTime) {
      const [date] = dateTime.split('T');
      return date;
    },
    toggleRecord() {
      useCveRecordLookupStore().showJsonRecord = !useCveRecordLookupStore().showJsonRecord;
    },
    create2DTable(affectedUnaffectedUnknownTable) {
      const tableWithHeaders = {
        headers: [],
        twoDTable: {},
      };

      // Build table headers: affected, and/or unaffected, and/or unknown
      affectedUnaffectedUnknownTable.forEach((row) => {
        if (tableWithHeaders.headers.indexOf(row.parentVersionStatus) < 0) tableWithHeaders.headers.push(row.parentVersionStatus);
      });
      tableWithHeaders.headers.sort();

      // Build 2D table w/ 'version'&'changes' or '' for table cell w/ no value
      affectedUnaffectedUnknownTable.forEach((row) => {
        // for each row fill in 'version'&'changes' or ''
        if (Object.prototype.hasOwnProperty.call(tableWithHeaders.twoDTable, row.parentVersionStatus)) {
          tableWithHeaders.twoDTable[row.parentVersionStatus].push(row);
        } else {
          tableWithHeaders.twoDTable[row.parentVersionStatus] = [row];
        }
      });
      return tableWithHeaders;
    }
  },
  beforeMount() {
    this.initializeFields();
    this.getContainersAndPopulateAccordionState();
  },
};
</script>

<style lang="scss" scoped>
@import '@/assets/style/globals.scss';
@import '@/assets/style/cveRecord.scss';


.columns {
  margin-top: 0rem !important;
}

.columns:not(:last-child) {
    margin-bottom: 0.5rem !important;
}

.cve-row {
  margin-left: unset !important;
  margin-right: unset !important;
}

.cve-versions-columns {
  padding-left: 4px !important;
}

// .cve-versions-column:not(:last-child) {
//   @include from($desktop) {
//     border-right: $theme-color-base-light solid 2px;
//   }

//   @include until($tablet) {
//     border-bottom: $theme-color-base-light solid 2px;
//   }
// }

td {
  width: 33% !important;
}

.cve-light-gray-table-header {
  text-transform: capitalize;
  background-color: $theme-color-base !important;
  border: 1px solid #F0F0F0 !important;
}

.cve-border-light-gray {
  border: 1px solid #F0F0F0;
}

.menu-list {
  margin-left: 1.5rem !important;
  margin-right: 0.25rem !important;
}

.cve-tag {
  background-color: $theme-color-violet-vivid-60 !important;
  color: white !important;
  font-weight: 600;
}

.cve-state-tag {
  background-color: $theme-color-blue-warm-20 !important;
  color: $theme-color-base-darkest !important;
}

.cve-tab {
  border: none;
  background: unset;
}
.cve-tab-active {
  font-weight: 700;
  border-top: none;
  border-right: none;
  border-left: none;
  border-bottom-left-radius: unset !important;
  border-bottom-right-radius: unset !important;
  border-bottom: 2px solid $theme-color-accent-warm ;
}

// fix and override Bulma icon with link alignment
.icon {
  display: inline-table;
  text-align: center;
}
</style>
